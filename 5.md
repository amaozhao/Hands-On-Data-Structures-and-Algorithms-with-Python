# 栈和队列

在本章中，我们将讨论两种非常重要的数据结构：栈和队列。 栈和队列有许多重要的应用，例如表单操作系统体系结构、算术表达式求值、负载平衡、管理打印作业和遍历数据。 在栈和队列数据结构中，数据是按顺序存储的，就像数组和链表一样，但与数组和链表不同的是，数据是按照特定的顺序处理的，并有一定的约束，我们将在本章中详细讨论。 此外，我们还将研究如何使用链表和数组来实现栈和队列。

在本章中，我们将讨论处理栈和队列中数据的约束和方法。 我们还将实现这些数据结构，并学习如何在 ```Python``` 中对这些数据结构应用不同的操作。

在本章中，我们将介绍以下内容：

- 如何使用各种方法实现栈和队列
- 栈和队列的一些实际示例应用程序

## 栈

栈是一种存储数据的数据结构，类似于厨房里的一叠盘子。 你可以把一个盘子放在栈顶，当你需要一个盘子时，你从栈顶拿走它。

添加到栈中的最后一个盘子将最先从栈中取出：

![](./images/05/5-1.png)

图 5.1：栈示例

上图描绘了一堆盘子。 只有将那个盘子留在堆的顶部才能将盘子添加到堆中。 从盘子堆中取出一个盘子意味着移除堆顶上的盘子。

栈是一种数据结构，它以类似于数组和链表的特定顺序存储数据，但有几个限制：

- 栈中的数据元素只能插入到最后（```push``` 操作）
- 一个栈中的数据元素只能从末尾删除（```pop``` 操作）
- 只能从栈中读取最后一个数据元素（```peek``` 操作）

栈数据结构允许我们从一端存储和读取数据，最后添加的元素首先被拾取。 因此，栈是后进先出 (**```LIFO```**) 结构，或后进后出 (**```LILO```**)。

在栈上执行两个主要操作——入栈和出栈。 当一个元素被添加到栈顶时，称为入栈操作，当一个元素要从栈顶取出（即移除）时，称为出栈操作。 另一个操作是 ```peek```，其中可以查看栈的顶部元素，而无需将其从栈中删除。 栈中的所有操作都是通过一个指针来进行的，这个指针一般命名为 ```top```。 所有这些操作如图 5.2 所示：

![](./images/05/5-2.png)

图 5.2：栈中压入和弹出操作的演示

下表演示了栈中两个重要的栈操作（```push``` 和 ```pop```）的使用：

|   栈操作   | Size |    Contents    |                      Operation results                       |
| :--------: | :--: | :------------: | :----------------------------------------------------------: |
|  stack()   |  0   |       []       |                   已创建栈对象，它是空的。                   |
| push "egg" |  1   |    ['egg']     |            一个了数据项 ```egg``` 被添加到栈中。             |
| push "ham" |  2   | ['egg', 'ham'] |               另一项 ```ham``` 被添加到栈中。                |
|   peek()   |  2   | ['egg', 'ham'] |                    返回顶部元素 ```ham```                    |
|   pop()    |  1   |    ['egg']     | ```ham``` 被弹出并返回。 （这个数据项是最后添加的，所以它首先被删除。） |
|   pop()    |  0   |       []       | ```egg``` 数据项被弹出并返回。 （这是添加的第一项，因此最后返回。） |

表 5.1：栈中不同操作的示例说明

栈用于许多事情。 栈的一种常见用法是在函数调用期间跟踪返回地址。 假设我们有以下程序：

```python
def b():
    print("b")

def a():
    b()

a()
print("done")
```

当程序执行到调用 ```a()``` 时，将遵循一系列事件以完成该程序的执行。 所有这些步骤的可视化如图 5.3 所示：

![](./images/05/5-3.png)

图 5.3：示例程序中函数调用期间一系列事件的步骤

事件的顺序如下：

1. 首先将当前指令的地址压入栈中，然后跳转到 ```a``` 的定义处执行
2. 在函数 ```a()``` 内部，函数 ```b()``` 被调用
3. 函数 ```b()``` 的返回地址被压入栈。 一旦 ```b()``` 中的指令和函数执行完成，返回地址就会从栈中弹出，这将我们带回函数 ```a()```
4. 当函数 ```a()``` 中的所有指令完成后，返回地址再次从栈中弹出，这将我们带回主程序和打印语句

上述程序的输出如下：

```python
b
done
```

我们现在已经讨论了栈数据结构的概念。 现在，让我们了解它在 ```Python``` 中使用数组和链表数据结构的实现。

### 使用数组的栈实现

栈像数组和链表一样按顺序存储数据，有一个特定的限制，即只能按照后进先出 (**```LIFO```**) 原则从栈的一端存储和读取数据。 一般来说，栈可以用数组和链表来实现。 基于数组的实现将具有固定长度的栈，而基于链表的实现可以具有可变长度的栈。

在栈的基于数组的实现（栈具有固定大小）的情况下，检查栈是否已满很重要，因为尝试将元素推入已满栈会产生错误， 称为溢出。 同样，尝试将弹出操作应用于空栈会导致称为下溢的错误。

让我们通过一个示例来理解使用数组的栈的实现，其中我们希望将三个数据元素```egg```、```ham``` 和```spam``` 压入栈。 首先，要使用入栈操作将新元素插入栈，我们检查溢出条件，即顶部指针指向数组的末尾索引。 栈顶指针是栈顶元素的索引位置。 如果顶部元素等于溢出条件，则不能添加新元素。 这是栈溢出情况。 如果数组中有空闲空间可以插入新元素，则将新数据压入栈。 图 5.4 显示了使用数组对栈进行压入操作的概览：

![](./images/05/5-4.png)

图 5.4：使用数组的栈实现中的推送操作序列

推送操作的 ```Python``` 代码如下：

```python
size = 3
data = [0] * (size)  # Initialize the stack
top = -1


def push(x):
    global top
    if top >= size - 1:
        print("Stack Overflow")
    else:
        top = top + 1
        data[top] = x
```

在上面的代码中，我们将栈初始化为固定大小（例如，在本例中为 ```3```），并将顶部指针指向 ```–1```，这表明栈为空。 此外，在 ```push``` 方法中，将顶部指针与栈的大小进行比较以检查溢出情况，如果栈已满，则打印栈溢出消息。 如果栈未满，栈顶指针加 ```1```，新的数据元素被添加到栈顶。 以下代码用于将数据元素插入栈：

```python
push('egg')
push('ham')
push('spam')
print(data[0 : top + 1] )
push('new')
push('new2')
```

在上面的代码中，当我们尝试插入前三个元素时，由于空间足够，所以添加了它们，但是当我们尝试添加数据元素 ```new``` 和 ```new2``` 时，栈已经满了，因此无法添加这两个元素 到栈。 这段代码的输出如下：

```python
['egg', 'ham', 'spam'] 
Stack Overflow 
Stack Overflow
```

接下来，```pop``` 操作返回栈顶元素的值，并将其从栈中移除。 首先，我们检查栈是否为空。 如果栈已经为空，则打印栈下溢消息。 否则，将顶部从栈中移除。 弹出操作的概览如图 5.5 所示：

![](./images/05/5-5.png)

图 5.5：使用数组的栈实现中的弹出操作顺序

```pop``` 操作的 ```Python``` 代码如下：

```python
def pop():
    global top
    if top == -1:
        print("Stack Underflow")
    else:
        top = top - 1
        data[top] = 0
        return data[top + 1]
```

在上面的代码中，我们首先通过检查栈是否为空来检查下溢情况。 如果顶部指针的值为 ```-1```，则表示栈为空。 否则，通过栈顶指针减 ```1``` 移除栈中的数据元素，并将栈顶数据元素返回给 ```main``` 函数。

假设我们已经向栈添加了三个数据元素，然后我们调用了四次 ```pop``` 函数。 由于栈中只有三个元素，所以移除了最开始的三个数据元素，当我们第四次尝试调用```pop``` 操作时，打印出栈下溢信息。 这显示在以下代码片段中：

```python
print(data[0 : top + 1])
pop()
pop()
pop()
pop()
print(data[0 : top + 1])
```

上述代码的输出如下：

```python
['egg', 'ham', 'spam']
Stack Underflow 
[]
```

接下来，让我们看一下 ```peek``` 操作的实现，其中我们返回栈顶元素的值。 ```Python``` 代码如下：

```python
def peek():
    global top
    if top == -1:
        print("Stack is empty")
    else:
        print(data[top])
```

在上面的代码中，首先我们检查栈顶指针的位置。 如果栈顶指针的值为 ```-1```，则表示栈为空，否则打印栈顶元素的值。

我们已经讨论了使用数组的栈的 ```Python``` 实现，接下来让我们讨论使用链表的栈实现。

### 使用链表的栈实现

为了使用链表实现栈，我们将编写 ```Stack``` 类，其中将声明所有方法； 但是，我们还将使用类似于我们在上一章中讨论的节点类：

```python
class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None
```

正如我们所知，链表中的节点保存数据和链表中下一项的引用。 使用链表实现栈数据结构可以被视为具有一些约束的标准链表，包括可以通过顶部指针从列表的末尾添加或删除元素（推送和弹出操作）。 如图 5.6 所示：

![](./images/05/5-6.png)

图 5.6：使用链表表示栈

现在让我们看看栈类。 它的实现与单向链表非常相似。 此外，我们需要两件事来实现栈：

- 我们首先需要知道栈顶是哪个节点，这样我们就可以通过这个节点进行 ```push``` 和 ```pop``` 操作
- 我们还想跟踪栈中的节点数，因此我们向 ```Stack``` 类添加一个 ```size``` 变量

考虑 ```Stack``` 类的以下代码片段：

```python
class Stack:
    def __init__(self):
        self.top = None
        self.size = 0
```

在上面的代码中，我们声明了 ```top``` 和 ```size``` 变量，它们被初始化为 ```None``` 和 ```0```。一旦我们初始化了 ```Stack``` 类，接下来，我们将在 ```Stack``` 类中实现不同的操作。 首先，让我们从推送操作的讨论开始。

### ```push``` 操作

```push``` 栈操作是对栈的重要操作； 它用于在栈顶部添加一个元素。 为了向栈中添加一个新节点，首先，我们检查栈中是否已经有一些项目或者它是否为空。 我们在这里不需要检查溢出条件，因为我们不需要固定栈的长度，这与使用数组的栈实现不同。

如果栈已经有一些元素，那么我们必须做两件事：

- 新节点的 ```next``` 指针必须指向先前位于顶部的节点
- 我们通过将 ```self.top``` 指向新添加的节点，将这个新节点放在栈的顶部

参见下图5.7中的两条指令：

![](./images/05/5-7.png)

图 5.7：压栈操作的工作原理

如果现有的栈是空的，而要添加的新节点是第一个元素，我们需要让这个节点成为元素的顶部节点。 因此，```self.top``` 将指向这个新节点。 参见下图 5.8：

![](./images/05/5-8.png)

图 5.8：将数据元素 ```egg``` 插入空栈

下面是 ```push``` 操作的完整实现，应该定义在 ```Stack``` 类中：

```python
    def push(self, data):
        # create a new node
        node = Node(data)
        if self.top:
            node.next = self.top
        self.top = node
        self.size += 1
```

在上面的代码中，我们创建了一个新节点并将数据存储在其中。 然后我们检查顶部指针的位置。 如果它不为空，则意味着栈不为空，我们添加新节点，更新两个指针，如图 5.7 所示。 在 ```else``` 部分，我们让 ```top``` 指针指向新节点。 最后，我们通过增加 ```self.size``` 变量来增加栈的大小。

要创建三个数据元素的栈，我们使用以下代码：

```python
words = Stack()
words.push("egg")
words.push("ham")
words.push("spam")
# print the stack elements.
current = words.top
while current:
    print(current.data)
    current = current.next
```


上述代码的输出如下：

```python
spam
ham
egg
```

在上面的代码中，我们创建了一个包含三个元素的栈——```egg```、```ham``` 和 ```spam```。 接下来，我们将讨论栈数据结构中的弹出操作。

### ```pop``` 操作

应用于栈的另一个重要操作是弹出操作。 在这个操作中，栈顶的元素被读取，然后从栈中移除。 ```pop``` 方法返回栈顶的元素，如果栈为空则返回 ```None```。

要在栈上实现弹出操作，我们执行以下操作：

1. 首先，检查栈是否为空。 不允许在空栈上进行弹出操作。
2. 如果栈不为空，则检查顶部节点是否具有指向其他节点的下一个属性。 如果是，则表示栈中包含元素，并且最顶层节点指向栈中的下一个节点。 要应用弹出操作，我们必须更改顶部指针。 下一个节点应该在顶部。 我们通过将 ```self.top``` 指向 ```self.top.next``` 来做到这一点。 请参见下图 5.9 以了解这一点：

![](./images/05/5-9.png)

图 5.9：栈上弹出操作的工作原理

3. 当栈中只有一个节点时，弹出操作后栈为空。 我们必须将顶部指针更改为 ```None```。 参见下图 5.10：

![](./images/05/5-10.png)

图 5.10：对一个元素的栈的弹出操作

4. 删除此节点会导致 ```self.top``` 指向 ```None```，如图 5.10 所示。
5. 如果栈不为空，我们还将栈的大小减 1。

下面是 ```Python``` 中栈出栈操作的代码，应该定义在 ```Stack``` 类中：

```python
    def pop(self):
        if self.top:
            data = self.top.data
            self.size -= 1
            self.top = self.top.next or None
            return data
        else:
            print("Stack is empty")
```

在上面的代码中，首先，我们检查了顶部指针的位置。 如果不为 ```None```，说明栈不为空，我们可以应用 ```pop``` 操作，如果栈中有多个数据元素，我们将栈顶指针移动到下一个节点（见图5.9） )，如果这是最后一个节点，我们将顶部指针指向 ```None```（见图 5.10）。 我们还通过递减 ```self.size``` 变量来减小栈的大小。

假设我们在栈中有三个数据元素。 我们可以使用下面的代码将出栈操作应用到栈上：

```python
words = Stack()
words.pop()
current = words.top
while current:
    print(current.data)
    current = current.next
```

上述代码的输出如下：

```python
ham
egg
```

在上面的代码中，我们从三个元素（```egg```、```ham```、```spam```）的栈中弹出了顶部元素。

接下来，我们将讨论用于栈数据结构的 ```peek``` 操作。

### ```peek``` 操作

还有一个可以应用于栈的重要操作——```peek``` 方法。 该方法返回栈顶元素而不将其从栈中删除。 ```peek``` 和 ```pop``` 之间的唯一区别是 ```peek``` 方法只返回最顶层的元素； 但是，在 ```pop``` 方法的情况下，返回最顶层的元素，并且该元素也从栈中删除。

```peek``` 操作允许我们在不更改栈的情况下查看顶部元素。 这个操作非常简单。 如果有顶层元素，返回它的数据； 否则，返回 ```None```（因此，```peek``` 的行为与 ```pop``` 的行为相匹配）。 ```peek``` 方法的实现如下（这个应该定义在 ```Stack``` 类中）：

```python
    def peek(self):
        if self.top:
            return self.top.data
        else:
            print("Stack is empty")
```

在上面的代码中，我们首先使用 ```self.top``` 检查顶部指针的位置。 如果不为空，则表示栈不为空，返回最顶层节点的数据值，否则打印栈为空的信息。 我们可以通过下面的代码使用 ```peek``` 方法获取栈顶元素：

```python
words.peek()
```

上述代码的输出是：

```python
spam
```

根据我们将三个数据元素添加到栈的原始示例，如果我们使用 ```peek``` 方法，我们将获得顶部元素 ```spam``` 作为输出。

栈是一种重要的数据结构，具有多个实际应用程序。 为了更好地理解栈的概念，我们将讨论这些应用程序之一：利用栈进行括号匹配。

### 栈的应用

正如我们所知，数组和链表数据结构可以做栈或队列数据结构（我们将在稍后讨论）可以做的任何事情。

尽管如此，这些数据结构还是很重要，因为它们有很多应用。 例如，在任何应用程序中，可能需要以特定顺序添加或删除任何元素。 栈和队列可用于此以避免程序中的任何潜在错误，可能是从列表中间访问/删除元素（这可能发生在数组和链表的情况下）。

现在让我们看一个示例括号匹配应用程序，看看我们如何使用我们的栈来实现它。

让我们编写一个函数 ```check_brackets``` 来验证包含括号（```( )```、```[ ]``` 或 ```{ }```）的给定表达式是否平衡，即右括号的数量是否与左括号的数量匹配。 栈可用于以相反顺序遍历项目列表，因为它们遵循 **```LILO```** 规则，这使它们成为解决此问题的不错选择。

以下代码用于在 ```Stack``` 类之外定义的单独的 ```check_brackets``` 方法。 此方法将使用我们在上一节中讨论的 ```Stack``` 类。 该方法将由字母字符和括号组成的表达式作为输入，并分别为给定表达式是否有效生成 ```True``` 或 ```False``` 作为输出。 ```check_brackets```方法的代码如下：

```python
def check_brackets(expression):
    brackets_stack = Stack()  # The stack class, we defined in previous section.
    last = " "
    for ch in expression:
        if ch in ("{", "[", "("):
            brackets_stack.push(ch)
        if ch in ("}", "]", ")"):
            last = brackets_stack.pop()
            if (
                last == "{"
                and ch == "}"
                or last == "["
                and ch == "]"
                or last == "("
                and ch == ")"
            ):
                continue
            else:
                return False
    return brackets_stack.size <= 0
```

上面的函数解析传递给它的表达式中的每个字符。 如果它得到一个开放的括号，它会将它推入栈。 如果它得到一个右括号，它将从栈中弹出顶部元素并比较两个括号以确保它们的类型匹配-```(```应该匹配```)```，```[```应该匹配```]```，和 ```{``` 应该匹配 ```}```。 如果他们不这样做，我们返回 ```False```； 否则，我们继续解析。

一旦到达表达式的末尾，我们需要进行最后一次检查。 如果栈是空的，那就没问题，我们可以返回 ```True```。 但是如果栈不为空，那么我们有一个没有匹配的右括号的左括号，我们将返回 ```False```。

我们可以使用以下代码测试括号匹配器：

```python
sl = (
    "{(foo)(bar)}[hello](((this)is)a)test",
    "{(foo)(bar)}[hello](((this)is)atest",
    "{(foo)(bar)}[hello](((this)is)a)test))",
)
for s in sl:
    m = check_brackets(s)
    print(f"{s}: {m}")
```

只有三个语句中的第一个应该匹配。 当我们运行代码时，我们得到以下输出：

```python
{(foo)(bar)}[hello](((this)is)a)test: True
{(foo)(bar)}[hello](((this)is)atest: False
{(foo)(bar)}[hello](((this)is)a)test)): False
```

在上面示例的三个表达式中，我们可以看到第一个表达式是有效的，而另外两个是无效的表达式。 因此，上述代码的输出为 ```True```、```False``` 和 ```False```。

综上所述，栈数据结构的 ```push```、```pop```、```peek``` 操作的时间复杂度为 $O(1)$，因为增删操作可以直接通过 ```top``` 指针在常数时间内进行。 栈数据结构简单； 但是，它用于在实际应用程序中实现许多功能。 例如，```Web``` 浏览器中的后退和前进按钮是使用栈实现的。 栈还用于在文字处理器中实现撤消和重做功能。

我们已经讨论了栈数据结构及其使用数组和链表的实现。 在下一节中，我们将讨论队列数据结构和可应用于队列的不同操作。